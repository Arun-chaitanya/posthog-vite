// Generated by kea-typegen on Thu, 20 Jul 2023 11:19:52 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { AvailableFeature, Experiment, ExperimentsTabs, ProgressStatus, UserType } from '../../types'
import type { FeatureFlagsSet } from '../../lib/logic/featureFlagLogic'

export interface experimentsLogicType extends Logic {
    actionCreators: {
        setSearchTerm: (searchTerm: string) => {
            type: 'set search term (scenes.experiments.experimentsLogic)'
            payload: {
                searchTerm: string
            }
        }
        setSearchStatus: (status: ProgressStatus | 'all') => {
            type: 'set search status (scenes.experiments.experimentsLogic)'
            payload: {
                status: 'all' | ProgressStatus
            }
        }
        setExperimentsTab: (tabKey: ExperimentsTabs) => {
            type: 'set experiments tab (scenes.experiments.experimentsLogic)'
            payload: {
                tabKey: ExperimentsTabs
            }
        }
        loadExperiments: () => {
            type: 'load experiments (scenes.experiments.experimentsLogic)'
            payload: any
        }
        loadExperimentsSuccess: (
            experiments: Experiment[],
            payload?: any
        ) => {
            type: 'load experiments success (scenes.experiments.experimentsLogic)'
            payload: {
                experiments: Experiment[]
                payload?: any
            }
        }
        loadExperimentsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load experiments failure (scenes.experiments.experimentsLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        deleteExperiment: (id: number) => {
            type: 'delete experiment (scenes.experiments.experimentsLogic)'
            payload: number
        }
        deleteExperimentSuccess: (
            experiments: Experiment[],
            payload?: number
        ) => {
            type: 'delete experiment success (scenes.experiments.experimentsLogic)'
            payload: {
                experiments: Experiment[]
                payload?: number
            }
        }
        deleteExperimentFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'delete experiment failure (scenes.experiments.experimentsLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        addToExperiments: (experiment: Experiment) => {
            type: 'add to experiments (scenes.experiments.experimentsLogic)'
            payload: Experiment
        }
        addToExperimentsSuccess: (
            experiments: Experiment[],
            payload?: Experiment
        ) => {
            type: 'add to experiments success (scenes.experiments.experimentsLogic)'
            payload: {
                experiments: Experiment[]
                payload?: Experiment
            }
        }
        addToExperimentsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'add to experiments failure (scenes.experiments.experimentsLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        updateExperiments: (experiment: Experiment) => {
            type: 'update experiments (scenes.experiments.experimentsLogic)'
            payload: Experiment
        }
        updateExperimentsSuccess: (
            experiments: Experiment[],
            payload?: Experiment
        ) => {
            type: 'update experiments success (scenes.experiments.experimentsLogic)'
            payload: {
                experiments: Experiment[]
                payload?: Experiment
            }
        }
        updateExperimentsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'update experiments failure (scenes.experiments.experimentsLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'set search term (scenes.experiments.experimentsLogic)': 'setSearchTerm'
        'set search status (scenes.experiments.experimentsLogic)': 'setSearchStatus'
        'set experiments tab (scenes.experiments.experimentsLogic)': 'setExperimentsTab'
        'load experiments (scenes.experiments.experimentsLogic)': 'loadExperiments'
        'load experiments success (scenes.experiments.experimentsLogic)': 'loadExperimentsSuccess'
        'load experiments failure (scenes.experiments.experimentsLogic)': 'loadExperimentsFailure'
        'delete experiment (scenes.experiments.experimentsLogic)': 'deleteExperiment'
        'delete experiment success (scenes.experiments.experimentsLogic)': 'deleteExperimentSuccess'
        'delete experiment failure (scenes.experiments.experimentsLogic)': 'deleteExperimentFailure'
        'add to experiments (scenes.experiments.experimentsLogic)': 'addToExperiments'
        'add to experiments success (scenes.experiments.experimentsLogic)': 'addToExperimentsSuccess'
        'add to experiments failure (scenes.experiments.experimentsLogic)': 'addToExperimentsFailure'
        'update experiments (scenes.experiments.experimentsLogic)': 'updateExperiments'
        'update experiments success (scenes.experiments.experimentsLogic)': 'updateExperimentsSuccess'
        'update experiments failure (scenes.experiments.experimentsLogic)': 'updateExperimentsFailure'
    }
    actionTypes: {
        setSearchTerm: 'set search term (scenes.experiments.experimentsLogic)'
        setSearchStatus: 'set search status (scenes.experiments.experimentsLogic)'
        setExperimentsTab: 'set experiments tab (scenes.experiments.experimentsLogic)'
        loadExperiments: 'load experiments (scenes.experiments.experimentsLogic)'
        loadExperimentsSuccess: 'load experiments success (scenes.experiments.experimentsLogic)'
        loadExperimentsFailure: 'load experiments failure (scenes.experiments.experimentsLogic)'
        deleteExperiment: 'delete experiment (scenes.experiments.experimentsLogic)'
        deleteExperimentSuccess: 'delete experiment success (scenes.experiments.experimentsLogic)'
        deleteExperimentFailure: 'delete experiment failure (scenes.experiments.experimentsLogic)'
        addToExperiments: 'add to experiments (scenes.experiments.experimentsLogic)'
        addToExperimentsSuccess: 'add to experiments success (scenes.experiments.experimentsLogic)'
        addToExperimentsFailure: 'add to experiments failure (scenes.experiments.experimentsLogic)'
        updateExperiments: 'update experiments (scenes.experiments.experimentsLogic)'
        updateExperimentsSuccess: 'update experiments success (scenes.experiments.experimentsLogic)'
        updateExperimentsFailure: 'update experiments failure (scenes.experiments.experimentsLogic)'
    }
    actions: {
        setSearchTerm: (searchTerm: string) => void
        setSearchStatus: (status: ProgressStatus | 'all') => void
        setExperimentsTab: (tabKey: ExperimentsTabs) => void
        loadExperiments: () => void
        loadExperimentsSuccess: (experiments: Experiment[], payload?: any) => void
        loadExperimentsFailure: (error: string, errorObject?: any) => void
        deleteExperiment: (id: number) => void
        deleteExperimentSuccess: (experiments: Experiment[], payload?: number) => void
        deleteExperimentFailure: (error: string, errorObject?: any) => void
        addToExperiments: (experiment: Experiment) => void
        addToExperimentsSuccess: (experiments: Experiment[], payload?: Experiment) => void
        addToExperimentsFailure: (error: string, errorObject?: any) => void
        updateExperiments: (experiment: Experiment) => void
        updateExperimentsSuccess: (experiments: Experiment[], payload?: Experiment) => void
        updateExperimentsFailure: (error: string, errorObject?: any) => void
    }
    asyncActions: {
        setSearchTerm: (searchTerm: string) => Promise<any>
        setSearchStatus: (status: ProgressStatus | 'all') => Promise<any>
        setExperimentsTab: (tabKey: ExperimentsTabs) => Promise<any>
        loadExperiments: () => Promise<any>
        loadExperimentsSuccess: (experiments: Experiment[], payload?: any) => Promise<any>
        loadExperimentsFailure: (error: string, errorObject?: any) => Promise<any>
        deleteExperiment: (id: number) => Promise<any>
        deleteExperimentSuccess: (experiments: Experiment[], payload?: number) => Promise<any>
        deleteExperimentFailure: (error: string, errorObject?: any) => Promise<any>
        addToExperiments: (experiment: Experiment) => Promise<any>
        addToExperimentsSuccess: (experiments: Experiment[], payload?: Experiment) => Promise<any>
        addToExperimentsFailure: (error: string, errorObject?: any) => Promise<any>
        updateExperiments: (experiment: Experiment) => Promise<any>
        updateExperimentsSuccess: (experiments: Experiment[], payload?: Experiment) => Promise<any>
        updateExperimentsFailure: (error: string, errorObject?: any) => Promise<any>
    }
    defaults: {
        searchTerm: any
        searchStatus: any
        tab: ExperimentsTabs
        experiments: Experiment[]
        experimentsLoading: boolean
    }
    events: {
        afterMount: () => void
    }
    key: undefined
    listeners: {}
    path: ['scenes', 'experiments', 'experimentsLogic']
    pathString: 'scenes.experiments.experimentsLogic'
    props: Record<string, unknown>
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        searchTerm: any
        searchStatus: any
        tab: ExperimentsTabs
        experiments: Experiment[]
        experimentsLoading: boolean
    }
    reducers: {
        searchTerm: (state: any, action: any, fullState: any) => any
        searchStatus: (state: any, action: any, fullState: any) => any
        tab: (state: ExperimentsTabs, action: any, fullState: any) => ExperimentsTabs
        experiments: (state: Experiment[], action: any, fullState: any) => Experiment[]
        experimentsLoading: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        searchTerm: any
        searchStatus: any
        tab: ExperimentsTabs
        experiments: Experiment[]
        experimentsLoading: boolean
    }
    selectors: {
        searchTerm: (state: any, props?: any) => any
        searchStatus: (state: any, props?: any) => any
        tab: (state: any, props?: any) => ExperimentsTabs
        experiments: (state: any, props?: any) => Experiment[]
        experimentsLoading: (state: any, props?: any) => boolean
        currentTeamId: (state: any, props?: any) => number | null
        user: (state: any, props?: any) => UserType | null
        hasAvailableFeature: (
            state: any,
            props?: any
        ) => (feature: AvailableFeature, currentUsage?: number | undefined) => boolean
        featureFlags: (state: any, props?: any) => FeatureFlagsSet
        filteredExperiments: (state: any, props?: any) => Experiment[]
        hasExperimentAvailableFeature: (state: any, props?: any) => boolean
        shouldShowEmptyState: (state: any, props?: any) => boolean
        shouldShowProductIntroduction: (state: any, props?: any) => boolean
    }
    sharedListeners: {}
    values: {
        searchTerm: any
        searchStatus: any
        tab: ExperimentsTabs
        experiments: Experiment[]
        experimentsLoading: boolean
        currentTeamId: number | null
        user: UserType | null
        hasAvailableFeature: (feature: AvailableFeature, currentUsage?: number | undefined) => boolean
        featureFlags: FeatureFlagsSet
        filteredExperiments: Experiment[]
        hasExperimentAvailableFeature: boolean
        shouldShowEmptyState: boolean
        shouldShowProductIntroduction: boolean
    }
    _isKea: true
    _isKeaWithKey: false
    __keaTypeGenInternalSelectorTypes: {
        filteredExperiments: (
            experiments: Experiment[],
            searchTerm: any,
            searchStatus: any,
            tab: ExperimentsTabs
        ) => Experiment[]
        hasExperimentAvailableFeature: (
            hasAvailableFeature: (feature: AvailableFeature, currentUsage?: number | undefined) => boolean
        ) => boolean
        shouldShowEmptyState: (experimentsLoading: boolean, filteredExperiments: Experiment[]) => boolean
        shouldShowProductIntroduction: (
            user:
                | import('/Users/arunchaitanya/Desktop/open-source/posthog-forked/posthog/frontend/src/types').UserType
                | null,
            featureFlags: import('/Users/arunchaitanya/Desktop/open-source/posthog-forked/posthog/frontend/src/lib/logic/featureFlagLogic').FeatureFlagsSet
        ) => boolean
    }
}
