// Generated by kea-typegen on Thu, 20 Jul 2023 11:19:46 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { ListActorsResponse, PersonModalLogicProps } from './personsModalLogic'
import type { ActorType, FilterType, GroupType, PropertiesTimelineFilterType } from '../../../types'
import type { Noun } from '../../../models/groupsModel'

export interface personsModalLogicType extends Logic {
    actionCreators: {
        setSearchTerm: (search: string) => {
            type: 'set search term (scenes.trends.personsModalLogic)'
            payload: {
                search: string
            }
        }
        saveCohortWithUrl: (cohortName: string) => {
            type: 'save cohort with url (scenes.trends.personsModalLogic)'
            payload: {
                cohortName: string
            }
        }
        resetActors: () => {
            type: 'reset actors (scenes.trends.personsModalLogic)'
            payload: boolean
        }
        closeModal: () => {
            type: 'close modal (scenes.trends.personsModalLogic)'
            payload: boolean
        }
        setIsCohortModalOpen: (isOpen: boolean) => {
            type: 'set is cohort modal open (scenes.trends.personsModalLogic)'
            payload: {
                isOpen: boolean
            }
        }
        reportPersonsModalViewed: (params: any) => {
            type: 'report persons modal viewed (scenes.trends.personsModalLogic)'
            payload: {
                params: any
            }
        }
        reportCohortCreatedFromPersonsModal: (filters: Partial<FilterType>) => {
            type: 'report cohort created from persons modal (scenes.trends.personsModalLogic)'
            payload: {
                filters: Partial<FilterType>
            }
        }
        loadActors: ({ url, clear }: { url: string; clear?: boolean }) => {
            type: 'load actors (scenes.trends.personsModalLogic)'
            payload: {
                url: string
                clear?: boolean
            }
        }
        loadActorsSuccess: (
            actorsResponse: ListActorsResponse | null,
            payload?: {
                url: string
                clear?: boolean
            }
        ) => {
            type: 'load actors success (scenes.trends.personsModalLogic)'
            payload: {
                actorsResponse: ListActorsResponse | null
                payload?: {
                    url: string
                    clear?: boolean
                }
            }
        }
        loadActorsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load actors failure (scenes.trends.personsModalLogic)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'set search term (scenes.trends.personsModalLogic)': 'setSearchTerm'
        'save cohort with url (scenes.trends.personsModalLogic)': 'saveCohortWithUrl'
        'reset actors (scenes.trends.personsModalLogic)': 'resetActors'
        'close modal (scenes.trends.personsModalLogic)': 'closeModal'
        'set is cohort modal open (scenes.trends.personsModalLogic)': 'setIsCohortModalOpen'
        'report persons modal viewed (scenes.trends.personsModalLogic)': 'reportPersonsModalViewed'
        'report cohort created from persons modal (scenes.trends.personsModalLogic)': 'reportCohortCreatedFromPersonsModal'
        'load actors (scenes.trends.personsModalLogic)': 'loadActors'
        'load actors success (scenes.trends.personsModalLogic)': 'loadActorsSuccess'
        'load actors failure (scenes.trends.personsModalLogic)': 'loadActorsFailure'
    }
    actionTypes: {
        setSearchTerm: 'set search term (scenes.trends.personsModalLogic)'
        saveCohortWithUrl: 'save cohort with url (scenes.trends.personsModalLogic)'
        resetActors: 'reset actors (scenes.trends.personsModalLogic)'
        closeModal: 'close modal (scenes.trends.personsModalLogic)'
        setIsCohortModalOpen: 'set is cohort modal open (scenes.trends.personsModalLogic)'
        reportPersonsModalViewed: 'report persons modal viewed (scenes.trends.personsModalLogic)'
        reportCohortCreatedFromPersonsModal: 'report cohort created from persons modal (scenes.trends.personsModalLogic)'
        loadActors: 'load actors (scenes.trends.personsModalLogic)'
        loadActorsSuccess: 'load actors success (scenes.trends.personsModalLogic)'
        loadActorsFailure: 'load actors failure (scenes.trends.personsModalLogic)'
    }
    actions: {
        setSearchTerm: (search: string) => void
        saveCohortWithUrl: (cohortName: string) => void
        resetActors: () => void
        closeModal: () => void
        setIsCohortModalOpen: (isOpen: boolean) => void
        reportPersonsModalViewed: (params: any) => void
        reportCohortCreatedFromPersonsModal: (filters: Partial<FilterType>) => void
        loadActors: ({ url, clear }: { url: string; clear?: boolean }) => void
        loadActorsSuccess: (
            actorsResponse: ListActorsResponse | null,
            payload?: {
                url: string
                clear?: boolean
            }
        ) => void
        loadActorsFailure: (error: string, errorObject?: any) => void
    }
    asyncActions: {
        setSearchTerm: (search: string) => Promise<any>
        saveCohortWithUrl: (cohortName: string) => Promise<any>
        resetActors: () => Promise<any>
        closeModal: () => Promise<any>
        setIsCohortModalOpen: (isOpen: boolean) => Promise<any>
        reportPersonsModalViewed: (params: any) => Promise<any>
        reportCohortCreatedFromPersonsModal: (filters: Partial<FilterType>) => Promise<any>
        loadActors: ({ url, clear }: { url: string; clear?: boolean }) => Promise<any>
        loadActorsSuccess: (
            actorsResponse: ListActorsResponse | null,
            payload?: {
                url: string
                clear?: boolean
            }
        ) => Promise<any>
        loadActorsFailure: (error: string, errorObject?: any) => Promise<any>
    }
    defaults: {
        actorsResponse: ListActorsResponse | null
        actorsResponseLoading: boolean
        actors: ActorType[]
        missingActorsCount: number
        searchTerm: string
        isModalOpen: boolean
        isCohortModalOpen: boolean
    }
    events: {}
    key: string
    listeners: {
        setSearchTerm: ((
            action: {
                type: 'set search term (scenes.trends.personsModalLogic)'
                payload: {
                    search: string
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        saveCohortWithUrl: ((
            action: {
                type: 'save cohort with url (scenes.trends.personsModalLogic)'
                payload: {
                    cohortName: string
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'trends', 'personsModalLogic']
    pathString: 'scenes.trends.personsModalLogic'
    props: PersonModalLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        actorsResponse: ListActorsResponse | null
        actorsResponseLoading: boolean
        actors: ActorType[]
        missingActorsCount: number
        searchTerm: string
        isModalOpen: boolean
        isCohortModalOpen: boolean
    }
    reducers: {
        actorsResponse: (state: ListActorsResponse | null, action: any, fullState: any) => ListActorsResponse | null
        actorsResponseLoading: (state: boolean, action: any, fullState: any) => boolean
        actors: (state: ActorType[], action: any, fullState: any) => ActorType[]
        missingActorsCount: (state: number, action: any, fullState: any) => number
        searchTerm: (state: string, action: any, fullState: any) => string
        isModalOpen: (state: boolean, action: any, fullState: any) => boolean
        isCohortModalOpen: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        actorsResponse: ListActorsResponse | null
        actorsResponseLoading: boolean
        actors: ActorType[]
        missingActorsCount: number
        searchTerm: string
        isModalOpen: boolean
        isCohortModalOpen: boolean
    }
    selectors: {
        actorsResponse: (state: any, props?: any) => ListActorsResponse | null
        actorsResponseLoading: (state: any, props?: any) => boolean
        actors: (state: any, props?: any) => ActorType[]
        missingActorsCount: (state: any, props?: any) => number
        searchTerm: (state: any, props?: any) => string
        isModalOpen: (state: any, props?: any) => boolean
        isCohortModalOpen: (state: any, props?: any) => boolean
        groupTypes: (state: any, props?: any) => Array<GroupType>
        aggregationLabel: (
            state: any,
            props?: any
        ) => (groupTypeIndex: number | null | undefined, deferToUserWording?: boolean) => Noun
        actorLabel: (state: any, props?: any) => Noun
        propertiesTimelineFilterFromUrl: (state: any, props?: any) => PropertiesTimelineFilterType
    }
    sharedListeners: {}
    values: {
        actorsResponse: ListActorsResponse | null
        actorsResponseLoading: boolean
        actors: ActorType[]
        missingActorsCount: number
        searchTerm: string
        isModalOpen: boolean
        isCohortModalOpen: boolean
        groupTypes: Array<GroupType>
        aggregationLabel: (groupTypeIndex: number | null | undefined, deferToUserWording?: boolean) => Noun
        actorLabel: Noun
        propertiesTimelineFilterFromUrl: PropertiesTimelineFilterType
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        actorLabel: (
            actors: ActorType[],
            aggregationLabel: (
                groupTypeIndex: number | null | undefined,
                deferToUserWording?: boolean | undefined
            ) => import('/Users/arunchaitanya/Desktop/open-source/posthog-forked/posthog/frontend/src/models/groupsModel').Noun
        ) => Noun
        propertiesTimelineFilterFromUrl: (url: string) => PropertiesTimelineFilterType
    }
}
