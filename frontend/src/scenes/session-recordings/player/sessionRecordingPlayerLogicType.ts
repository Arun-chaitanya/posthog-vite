// Generated by kea-typegen on Sun, 06 Aug 2023 18:21:19 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { Player, SessionRecordingPlayerLogicProps } from './sessionRecordingPlayerLogic'
import type { AvailableFeature, MatchedRecording, MatchedRecordingEvent, RecordingSegment, SessionPlayerData, SessionPlayerState, SessionRecordingType } from '../../../types'
import type { RecordingViewedSummaryAnalytics } from '../../../lib/utils/eventUsageLogic'
import type { SessionRecordingPlayerExplorerProps } from './view-explorer/SessionRecordingPlayerExplorer'

export interface sessionRecordingPlayerLogicType extends Logic {
    actionCreators: {
        maybeLoadRecordingMeta: () => {
            type: 'maybe load recording meta (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        loadRecordingSnapshots: () => {
            type: 'load recording snapshots (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        loadRecordingSnapshotsSuccess: () => {
            type: 'load recording snapshots success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        loadRecordingSnapshotsFailure: () => {
            type: 'load recording snapshots failure (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        loadRecordingMetaSuccess: (
            sessionPlayerMetaData: SessionRecordingType | null,
            payload?: {
                value: true
            }
        ) => {
            type: 'load recording meta success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                sessionPlayerMetaData: SessionRecordingType | null
                payload?: {
                    value: true
                }
            }
        }
        setSkipInactivitySetting: (skipInactivitySetting: boolean) => {
            type: 'set skip inactivity setting (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                skipInactivitySetting: boolean
            }
        }
        setSpeed: (speed: number) => {
            type: 'set speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                speed: number
            }
        }
        reportRecordingPlayerSpeedChanged: (newSpeed: number) => {
            type: 'report recording player speed changed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                newSpeed: number
            }
        }
        reportRecordingPlayerSkipInactivityToggled: (skipInactivity: boolean) => {
            type: 'report recording player skip inactivity toggled (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                skipInactivity: boolean
            }
        }
        reportRecordingViewedSummary: (recordingViewedSummary: RecordingViewedSummaryAnalytics) => {
            type: 'report recording viewed summary (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                recordingViewedSummary: RecordingViewedSummaryAnalytics
            }
        }
        reportNextRecordingTriggered: (automatic: boolean) => {
            type: 'report next recording triggered (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                automatic: boolean
            }
        }
        reportRecordingExportedToFile: () => {
            type: 'report recording exported to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        tryInitReplayer: () => {
            type: 'try init replayer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: boolean
        }
        setPlayer: (player: Player | null) => {
            type: 'set player (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                player: Player | null
            }
        }
        setPlay: () => {
            type: 'set play (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setPause: () => {
            type: 'set pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setEndReached: (reached?: boolean) => {
            type: 'set end reached (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                reached: boolean
            }
        }
        startBuffer: () => {
            type: 'start buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        endBuffer: () => {
            type: 'end buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        startScrub: () => {
            type: 'start scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        endScrub: () => {
            type: 'end scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setErrorPlayerState: (show: boolean) => {
            type: 'set error player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                show: boolean
            }
        }
        setSkippingInactivity: (isSkippingInactivity: boolean) => {
            type: 'set skipping inactivity (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                isSkippingInactivity: boolean
            }
        }
        syncPlayerSpeed: () => {
            type: 'sync player speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setCurrentTimestamp: (timestamp: number) => {
            type: 'set current timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                timestamp: number
            }
        }
        setScale: (scale: number) => {
            type: 'set scale (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                scale: number
            }
        }
        togglePlayPause: () => {
            type: 'toggle play pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        seekToTimestamp: (
            timestamp: number,
            forcePlay?: boolean
        ) => {
            type: 'seek to timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                timestamp: number
                forcePlay: boolean
            }
        }
        seekToTime: (timeInMilliseconds: number) => {
            type: 'seek to time (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                timeInMilliseconds: number
            }
        }
        seekForward: (amount?: number) => {
            type: 'seek forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                amount: number | undefined
            }
        }
        seekBackward: (amount?: number) => {
            type: 'seek backward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                amount: number | undefined
            }
        }
        resolvePlayerState: () => {
            type: 'resolve player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        updateAnimation: () => {
            type: 'update animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        stopAnimation: () => {
            type: 'stop animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setCurrentSegment: (segment: RecordingSegment) => {
            type: 'set current segment (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                segment: RecordingSegment
            }
        }
        setRootFrame: (frame: HTMLDivElement) => {
            type: 'set root frame (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                frame: HTMLDivElement
            }
        }
        checkBufferingCompleted: () => {
            type: 'check buffering completed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        initializePlayerFromStart: () => {
            type: 'initialize player from start (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        incrementErrorCount: () => {
            type: 'increment error count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        incrementWarningCount: (count?: number) => {
            type: 'increment warning count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                count: number
            }
        }
        setMatching: (matching: SessionRecordingType['matching_events']) => {
            type: 'set matching (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                matching: MatchedRecording[] | undefined
            }
        }
        updateFromMetadata: () => {
            type: 'update from metadata (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        exportRecordingToFile: () => {
            type: 'export recording to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        deleteRecording: () => {
            type: 'delete recording (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        openExplorer: () => {
            type: 'open explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        closeExplorer: () => {
            type: 'close explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                value: true
            }
        }
        setExplorerProps: (props: SessionRecordingPlayerExplorerProps | null) => {
            type: 'set explorer props (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                props: SessionRecordingPlayerExplorerProps | null
            }
        }
        setIsFullScreen: (isFullScreen: boolean) => {
            type: 'set is full screen (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                isFullScreen: boolean
            }
        }
        skipPlayerForward: (
            rrWebPlayerTime: number,
            skip: number
        ) => {
            type: 'skip player forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
            payload: {
                rrWebPlayerTime: number
                skip: number
            }
        }
    }
    actionKeys: {
        'maybe load recording meta (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'maybeLoadRecordingMeta'
        'load recording snapshots (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'loadRecordingSnapshots'
        'load recording snapshots success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'loadRecordingSnapshotsSuccess'
        'load recording snapshots failure (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'loadRecordingSnapshotsFailure'
        'load recording meta success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'loadRecordingMetaSuccess'
        'set skip inactivity setting (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setSkipInactivitySetting'
        'set speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setSpeed'
        'report recording player speed changed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'reportRecordingPlayerSpeedChanged'
        'report recording player skip inactivity toggled (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'reportRecordingPlayerSkipInactivityToggled'
        'report recording viewed summary (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'reportRecordingViewedSummary'
        'report next recording triggered (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'reportNextRecordingTriggered'
        'report recording exported to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'reportRecordingExportedToFile'
        'try init replayer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'tryInitReplayer'
        'set player (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setPlayer'
        'set play (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setPlay'
        'set pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setPause'
        'set end reached (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setEndReached'
        'start buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'startBuffer'
        'end buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'endBuffer'
        'start scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'startScrub'
        'end scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'endScrub'
        'set error player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setErrorPlayerState'
        'set skipping inactivity (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setSkippingInactivity'
        'sync player speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'syncPlayerSpeed'
        'set current timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setCurrentTimestamp'
        'set scale (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setScale'
        'toggle play pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'togglePlayPause'
        'seek to timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'seekToTimestamp'
        'seek to time (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'seekToTime'
        'seek forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'seekForward'
        'seek backward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'seekBackward'
        'resolve player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'resolvePlayerState'
        'update animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'updateAnimation'
        'stop animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'stopAnimation'
        'set current segment (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setCurrentSegment'
        'set root frame (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setRootFrame'
        'check buffering completed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'checkBufferingCompleted'
        'initialize player from start (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'initializePlayerFromStart'
        'increment error count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'incrementErrorCount'
        'increment warning count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'incrementWarningCount'
        'set matching (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setMatching'
        'update from metadata (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'updateFromMetadata'
        'export recording to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'exportRecordingToFile'
        'delete recording (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'deleteRecording'
        'open explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'openExplorer'
        'close explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'closeExplorer'
        'set explorer props (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setExplorerProps'
        'set is full screen (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'setIsFullScreen'
        'skip player forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)': 'skipPlayerForward'
    }
    actionTypes: {
        maybeLoadRecordingMeta: 'maybe load recording meta (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        loadRecordingSnapshots: 'load recording snapshots (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        loadRecordingSnapshotsSuccess: 'load recording snapshots success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        loadRecordingSnapshotsFailure: 'load recording snapshots failure (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        loadRecordingMetaSuccess: 'load recording meta success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setSkipInactivitySetting: 'set skip inactivity setting (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setSpeed: 'set speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        reportRecordingPlayerSpeedChanged: 'report recording player speed changed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        reportRecordingPlayerSkipInactivityToggled: 'report recording player skip inactivity toggled (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        reportRecordingViewedSummary: 'report recording viewed summary (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        reportNextRecordingTriggered: 'report next recording triggered (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        reportRecordingExportedToFile: 'report recording exported to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        tryInitReplayer: 'try init replayer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setPlayer: 'set player (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setPlay: 'set play (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setPause: 'set pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setEndReached: 'set end reached (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        startBuffer: 'start buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        endBuffer: 'end buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        startScrub: 'start scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        endScrub: 'end scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setErrorPlayerState: 'set error player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setSkippingInactivity: 'set skipping inactivity (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        syncPlayerSpeed: 'sync player speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setCurrentTimestamp: 'set current timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setScale: 'set scale (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        togglePlayPause: 'toggle play pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        seekToTimestamp: 'seek to timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        seekToTime: 'seek to time (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        seekForward: 'seek forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        seekBackward: 'seek backward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        resolvePlayerState: 'resolve player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        updateAnimation: 'update animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        stopAnimation: 'stop animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setCurrentSegment: 'set current segment (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setRootFrame: 'set root frame (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        checkBufferingCompleted: 'check buffering completed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        initializePlayerFromStart: 'initialize player from start (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        incrementErrorCount: 'increment error count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        incrementWarningCount: 'increment warning count (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setMatching: 'set matching (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        updateFromMetadata: 'update from metadata (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        exportRecordingToFile: 'export recording to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        deleteRecording: 'delete recording (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        openExplorer: 'open explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        closeExplorer: 'close explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setExplorerProps: 'set explorer props (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        setIsFullScreen: 'set is full screen (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
        skipPlayerForward: 'skip player forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
    }
    actions: {
        maybeLoadRecordingMeta: () => void
        loadRecordingSnapshots: () => void
        loadRecordingSnapshotsSuccess: () => void
        loadRecordingSnapshotsFailure: () => void
        loadRecordingMetaSuccess: (
            sessionPlayerMetaData: SessionRecordingType | null,
            payload?: {
                value: true
            }
        ) => void
        setSkipInactivitySetting: (skipInactivitySetting: boolean) => void
        setSpeed: (speed: number) => void
        reportRecordingPlayerSpeedChanged: (newSpeed: number) => void
        reportRecordingPlayerSkipInactivityToggled: (skipInactivity: boolean) => void
        reportRecordingViewedSummary: (recordingViewedSummary: RecordingViewedSummaryAnalytics) => void
        reportNextRecordingTriggered: (automatic: boolean) => void
        reportRecordingExportedToFile: () => void
        tryInitReplayer: () => void
        setPlayer: (player: Player | null) => void
        setPlay: () => void
        setPause: () => void
        setEndReached: (reached?: boolean) => void
        startBuffer: () => void
        endBuffer: () => void
        startScrub: () => void
        endScrub: () => void
        setErrorPlayerState: (show: boolean) => void
        setSkippingInactivity: (isSkippingInactivity: boolean) => void
        syncPlayerSpeed: () => void
        setCurrentTimestamp: (timestamp: number) => void
        setScale: (scale: number) => void
        togglePlayPause: () => void
        seekToTimestamp: (timestamp: number, forcePlay?: boolean) => void
        seekToTime: (timeInMilliseconds: number) => void
        seekForward: (amount?: number) => void
        seekBackward: (amount?: number) => void
        resolvePlayerState: () => void
        updateAnimation: () => void
        stopAnimation: () => void
        setCurrentSegment: (segment: RecordingSegment) => void
        setRootFrame: (frame: HTMLDivElement) => void
        checkBufferingCompleted: () => void
        initializePlayerFromStart: () => void
        incrementErrorCount: () => void
        incrementWarningCount: (count?: number) => void
        setMatching: (matching: SessionRecordingType['matching_events']) => void
        updateFromMetadata: () => void
        exportRecordingToFile: () => void
        deleteRecording: () => void
        openExplorer: () => void
        closeExplorer: () => void
        setExplorerProps: (props: SessionRecordingPlayerExplorerProps | null) => void
        setIsFullScreen: (isFullScreen: boolean) => void
        skipPlayerForward: (rrWebPlayerTime: number, skip: number) => void
    }
    asyncActions: {
        maybeLoadRecordingMeta: () => Promise<any>
        loadRecordingSnapshots: () => Promise<any>
        loadRecordingSnapshotsSuccess: () => Promise<any>
        loadRecordingSnapshotsFailure: () => Promise<any>
        loadRecordingMetaSuccess: (
            sessionPlayerMetaData: SessionRecordingType | null,
            payload?: {
                value: true
            }
        ) => Promise<any>
        setSkipInactivitySetting: (skipInactivitySetting: boolean) => Promise<any>
        setSpeed: (speed: number) => Promise<any>
        reportRecordingPlayerSpeedChanged: (newSpeed: number) => Promise<any>
        reportRecordingPlayerSkipInactivityToggled: (skipInactivity: boolean) => Promise<any>
        reportRecordingViewedSummary: (recordingViewedSummary: RecordingViewedSummaryAnalytics) => Promise<any>
        reportNextRecordingTriggered: (automatic: boolean) => Promise<any>
        reportRecordingExportedToFile: () => Promise<any>
        tryInitReplayer: () => Promise<any>
        setPlayer: (player: Player | null) => Promise<any>
        setPlay: () => Promise<any>
        setPause: () => Promise<any>
        setEndReached: (reached?: boolean) => Promise<any>
        startBuffer: () => Promise<any>
        endBuffer: () => Promise<any>
        startScrub: () => Promise<any>
        endScrub: () => Promise<any>
        setErrorPlayerState: (show: boolean) => Promise<any>
        setSkippingInactivity: (isSkippingInactivity: boolean) => Promise<any>
        syncPlayerSpeed: () => Promise<any>
        setCurrentTimestamp: (timestamp: number) => Promise<any>
        setScale: (scale: number) => Promise<any>
        togglePlayPause: () => Promise<any>
        seekToTimestamp: (timestamp: number, forcePlay?: boolean) => Promise<any>
        seekToTime: (timeInMilliseconds: number) => Promise<any>
        seekForward: (amount?: number) => Promise<any>
        seekBackward: (amount?: number) => Promise<any>
        resolvePlayerState: () => Promise<any>
        updateAnimation: () => Promise<any>
        stopAnimation: () => Promise<any>
        setCurrentSegment: (segment: RecordingSegment) => Promise<any>
        setRootFrame: (frame: HTMLDivElement) => Promise<any>
        checkBufferingCompleted: () => Promise<any>
        initializePlayerFromStart: () => Promise<any>
        incrementErrorCount: () => Promise<any>
        incrementWarningCount: (count?: number) => Promise<any>
        setMatching: (matching: SessionRecordingType['matching_events']) => Promise<any>
        updateFromMetadata: () => Promise<any>
        exportRecordingToFile: () => Promise<any>
        deleteRecording: () => Promise<any>
        openExplorer: () => Promise<any>
        closeExplorer: () => Promise<any>
        setExplorerProps: (props: SessionRecordingPlayerExplorerProps | null) => Promise<any>
        setIsFullScreen: (isFullScreen: boolean) => Promise<any>
        skipPlayerForward: (rrWebPlayerTime: number, skip: number) => Promise<any>
    }
    defaults: {
        rootFrame: HTMLDivElement | null
        player: Player | null
        currentTimestamp: number | undefined
        timestampChangeTracking: {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: RecordingSegment | null
        isSkippingInactivity: boolean
        scale: number
        playingState: SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: boolean
        isErrored: boolean
        isScrubbing: boolean
        errorCount: number
        warningCount: number
        matching: MatchedRecording[] | undefined
        endReached: boolean
        explorerMode: SessionRecordingPlayerExplorerProps | null
        isFullScreen: boolean
        isSmallScreen: boolean
    }
    events: {}
    key: string
    listeners: {
        skipPlayerForward: ((
            action: {
                type: 'skip player forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    rrWebPlayerTime: number
                    skip: number
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setRootFrame: ((
            action: {
                type: 'set root frame (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    frame: HTMLDivElement
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        tryInitReplayer: ((
            action: {
                type: 'try init replayer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: boolean
            },
            previousState: any
        ) => void | Promise<void>)[]
        setPlayer: ((
            action: {
                type: 'set player (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    player: Player | null
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setCurrentSegment: ((
            action: {
                type: 'set current segment (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    segment: RecordingSegment
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setSkipInactivitySetting: ((
            action: {
                type: 'set skip inactivity setting (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    skipInactivitySetting: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setSkippingInactivity: ((
            action: {
                type: 'set skipping inactivity (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    isSkippingInactivity: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        syncPlayerSpeed: ((
            action: {
                type: 'sync player speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        checkBufferingCompleted: ((
            action: {
                type: 'check buffering completed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        initializePlayerFromStart: ((
            action: {
                type: 'initialize player from start (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        updateFromMetadata: ((
            action: {
                type: 'update from metadata (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadRecordingMetaSuccess: ((
            action: {
                type: 'load recording meta success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    sessionPlayerMetaData: SessionRecordingType | null
                    payload?: {
                        value: true
                    }
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadRecordingSnapshotsSuccess: ((
            action: {
                type: 'load recording snapshots success (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadRecordingSnapshotsFailure: ((
            action: {
                type: 'load recording snapshots failure (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setPlay: ((
            action: {
                type: 'set play (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setPause: ((
            action: {
                type: 'set pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setEndReached: ((
            action: {
                type: 'set end reached (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    reached: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        startBuffer: ((
            action: {
                type: 'start buffer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setErrorPlayerState: ((
            action: {
                type: 'set error player state (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    show: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        startScrub: ((
            action: {
                type: 'start scrub (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setSpeed: ((
            action: {
                type: 'set speed (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    speed: number
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        seekToTimestamp: ((
            action: {
                type: 'seek to timestamp (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    timestamp: number
                    forcePlay: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        seekForward: ((
            action: {
                type: 'seek forward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    amount: number | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        seekBackward: ((
            action: {
                type: 'seek backward (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    amount: number | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        seekToTime: ((
            action: {
                type: 'seek to time (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    timeInMilliseconds: number
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        togglePlayPause: ((
            action: {
                type: 'toggle play pause (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        updateAnimation: ((
            action: {
                type: 'update animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        stopAnimation: ((
            action: {
                type: 'stop animation (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        exportRecordingToFile: ((
            action: {
                type: 'export recording to file (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        deleteRecording: ((
            action: {
                type: 'delete recording (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        openExplorer: ((
            action: {
                type: 'open explorer (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setIsFullScreen: ((
            action: {
                type: 'set is full screen (scenes.session-recordings.player.sessionRecordingPlayerLogic.*)'
                payload: {
                    isFullScreen: boolean
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'session-recordings', 'player', 'sessionRecordingPlayerLogic', '*']
    pathString: 'scenes.session-recordings.player.sessionRecordingPlayerLogic.*'
    props: SessionRecordingPlayerLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        rootFrame: HTMLDivElement | null
        player: Player | null
        currentTimestamp: number | undefined
        timestampChangeTracking: {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: RecordingSegment | null
        isSkippingInactivity: boolean
        scale: number
        playingState: SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: boolean
        isErrored: boolean
        isScrubbing: boolean
        errorCount: number
        warningCount: number
        matching: MatchedRecording[] | undefined
        endReached: boolean
        explorerMode: SessionRecordingPlayerExplorerProps | null
        isFullScreen: boolean
        isSmallScreen: boolean
    }
    reducers: {
        rootFrame: (state: HTMLDivElement | null, action: any, fullState: any) => HTMLDivElement | null
        player: (state: Player | null, action: any, fullState: any) => Player | null
        currentTimestamp: (state: number | undefined, action: any, fullState: any) => number | undefined
        timestampChangeTracking: (
            state: {
                timestamp: number | null
                timestampMatchesPrevious: number
            },
            action: any,
            fullState: any
        ) => {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: (state: RecordingSegment | null, action: any, fullState: any) => RecordingSegment | null
        isSkippingInactivity: (state: boolean, action: any, fullState: any) => boolean
        scale: (state: number, action: any, fullState: any) => number
        playingState: (
            state: SessionPlayerState.PLAY | SessionPlayerState.PAUSE,
            action: any,
            fullState: any
        ) => SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: (state: boolean, action: any, fullState: any) => boolean
        isErrored: (state: boolean, action: any, fullState: any) => boolean
        isScrubbing: (state: boolean, action: any, fullState: any) => boolean
        errorCount: (state: number, action: any, fullState: any) => number
        warningCount: (state: number, action: any, fullState: any) => number
        matching: (state: MatchedRecording[] | undefined, action: any, fullState: any) => MatchedRecording[] | undefined
        endReached: (state: boolean, action: any, fullState: any) => boolean
        explorerMode: (
            state: SessionRecordingPlayerExplorerProps | null,
            action: any,
            fullState: any
        ) => SessionRecordingPlayerExplorerProps | null
        isFullScreen: (state: boolean, action: any, fullState: any) => boolean
        isSmallScreen: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        rootFrame: HTMLDivElement | null
        player: Player | null
        currentTimestamp: number | undefined
        timestampChangeTracking: {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: RecordingSegment | null
        isSkippingInactivity: boolean
        scale: number
        playingState: SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: boolean
        isErrored: boolean
        isScrubbing: boolean
        errorCount: number
        warningCount: number
        matching: MatchedRecording[] | undefined
        endReached: boolean
        explorerMode: SessionRecordingPlayerExplorerProps | null
        isFullScreen: boolean
        isSmallScreen: boolean
    }
    selectors: {
        rootFrame: (state: any, props?: any) => HTMLDivElement | null
        player: (state: any, props?: any) => Player | null
        currentTimestamp: (state: any, props?: any) => number | undefined
        timestampChangeTracking: (
            state: any,
            props?: any
        ) => {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: (state: any, props?: any) => RecordingSegment | null
        isSkippingInactivity: (state: any, props?: any) => boolean
        scale: (state: any, props?: any) => number
        playingState: (state: any, props?: any) => SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: (state: any, props?: any) => boolean
        isErrored: (state: any, props?: any) => boolean
        isScrubbing: (state: any, props?: any) => boolean
        errorCount: (state: any, props?: any) => number
        warningCount: (state: any, props?: any) => number
        matching: (state: any, props?: any) => MatchedRecording[] | undefined
        endReached: (state: any, props?: any) => boolean
        explorerMode: (state: any, props?: any) => SessionRecordingPlayerExplorerProps | null
        isFullScreen: (state: any, props?: any) => boolean
        isSmallScreen: (state: any, props?: any) => boolean
        snapshotsLoaded: (state: any, props?: any) => boolean
        sessionPlayerMetaDataLoading: (state: any, props?: any) => boolean
        sessionPlayerSnapshotDataLoading: (state: any, props?: any) => boolean
        sessionPlayerData: (state: any, props?: any) => SessionPlayerData
        speed: (state: any, props?: any) => number
        skipInactivitySetting: (state: any, props?: any) => boolean
        hasAvailableFeature: (
            state: any,
            props?: any
        ) => (feature: AvailableFeature, currentUsage?: number | undefined) => boolean
        sessionRecordingId: (state: any, props?: any) => string
        logicProps: (state: any, props?: any) => SessionRecordingPlayerLogicProps
        currentPlayerState: (
            state: any,
            props?: any
        ) =>
            | SessionPlayerState.READY
            | SessionPlayerState.BUFFER
            | SessionPlayerState.PLAY
            | SessionPlayerState.PAUSE
            | SessionPlayerState.SKIP
            | SessionPlayerState.ERROR
        currentPlayerTime: (state: any, props?: any) => number
        toRRWebPlayerTime: (state: any, props?: any) => (timestamp: number) => number | undefined
        fromRRWebPlayerTime: (state: any, props?: any) => (time?: number | undefined) => number | undefined
        jumpTimeMs: (state: any, props?: any) => number
        matchingEvents: (state: any, props?: any) => MatchedRecordingEvent[]
        playerSpeed: (state: any, props?: any) => number
        segmentForTimestamp: (state: any, props?: any) => (timestamp?: number | undefined) => RecordingSegment | null
    }
    sharedListeners: {}
    values: {
        rootFrame: HTMLDivElement | null
        player: Player | null
        currentTimestamp: number | undefined
        timestampChangeTracking: {
            timestamp: number | null
            timestampMatchesPrevious: number
        }
        currentSegment: RecordingSegment | null
        isSkippingInactivity: boolean
        scale: number
        playingState: SessionPlayerState.PLAY | SessionPlayerState.PAUSE
        isBuffering: boolean
        isErrored: boolean
        isScrubbing: boolean
        errorCount: number
        warningCount: number
        matching: MatchedRecording[] | undefined
        endReached: boolean
        explorerMode: SessionRecordingPlayerExplorerProps | null
        isFullScreen: boolean
        isSmallScreen: boolean
        snapshotsLoaded: boolean
        sessionPlayerMetaDataLoading: boolean
        sessionPlayerSnapshotDataLoading: boolean
        sessionPlayerData: SessionPlayerData
        speed: number
        skipInactivitySetting: boolean
        hasAvailableFeature: (feature: AvailableFeature, currentUsage?: number | undefined) => boolean
        sessionRecordingId: string
        logicProps: SessionRecordingPlayerLogicProps
        currentPlayerState:
            | SessionPlayerState.READY
            | SessionPlayerState.BUFFER
            | SessionPlayerState.PLAY
            | SessionPlayerState.PAUSE
            | SessionPlayerState.SKIP
            | SessionPlayerState.ERROR
        currentPlayerTime: number
        toRRWebPlayerTime: (timestamp: number) => number | undefined
        fromRRWebPlayerTime: (time?: number | undefined) => number | undefined
        jumpTimeMs: number
        matchingEvents: MatchedRecordingEvent[]
        playerSpeed: number
        segmentForTimestamp: (timestamp?: number | undefined) => RecordingSegment | null
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        sessionRecordingId: (arg: any) => string
        logicProps: (arg: any) => SessionRecordingPlayerLogicProps
        currentPlayerState: (
            playingState: SessionPlayerState.PLAY | SessionPlayerState.PAUSE,
            isBuffering: boolean,
            isErrored: boolean,
            isScrubbing: boolean,
            isSkippingInactivity: boolean,
            snapshotsLoaded: boolean,
            sessionPlayerSnapshotDataLoading: boolean
        ) =>
            | SessionPlayerState.READY
            | SessionPlayerState.BUFFER
            | SessionPlayerState.PLAY
            | SessionPlayerState.PAUSE
            | SessionPlayerState.SKIP
            | SessionPlayerState.ERROR
        currentPlayerTime: (currentTimestamp: number | undefined, sessionPlayerData: SessionPlayerData) => number
        toRRWebPlayerTime: (
            sessionPlayerData: SessionPlayerData,
            currentSegment: RecordingSegment | null
        ) => (timestamp: number) => number | undefined
        fromRRWebPlayerTime: (
            sessionPlayerData: SessionPlayerData,
            currentSegment: RecordingSegment | null
        ) => (time?: number | undefined) => number | undefined
        jumpTimeMs: (speed: number) => number
        matchingEvents: (matching: MatchedRecording[] | undefined) => MatchedRecordingEvent[]
        playerSpeed: (
            speed: number,
            isSkippingInactivity: boolean,
            currentSegment: RecordingSegment | null,
            currentTimestamp: number | undefined
        ) => number
        segmentForTimestamp: (
            sessionPlayerData: SessionPlayerData
        ) => (timestamp?: number | undefined) => RecordingSegment | null
    }
}
