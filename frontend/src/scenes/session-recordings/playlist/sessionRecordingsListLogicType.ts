// Generated by kea-typegen on Sun, 06 Aug 2023 19:07:53 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic } from 'kea'

import type { SessionRecordingListLogicProps } from './sessionRecordingsListLogic'
import type { SessionRecordingFilterType } from '../../../lib/utils/eventUsageLogic'
import type { AutoplayDirection, RecordingFilters, SessionRecordingType, SessionRecordingsResponse } from '../../../types'
import type { FeatureFlagsSet } from '../../../lib/logic/featureFlagLogic'

export interface sessionRecordingsListLogicType extends Logic {
    actionCreators: {
        reportRecordingsListFetched: (
            loadTime: number,
            listingVersion: '1' | '3'
        ) => {
            type: 'report recordings list fetched (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                loadTime: number
                listingVersion: '1' | '3'
            }
        }
        reportRecordingsListFilterAdded: (filterType: SessionRecordingFilterType) => {
            type: 'report recordings list filter added (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                filterType: SessionRecordingFilterType
            }
        }
        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => {
            type: 'maybe load properties for sessions (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                sessions: SessionRecordingType[]
            }
        }
        setFilters: (filters: Partial<RecordingFilters>) => {
            type: 'set filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                filters: Partial<RecordingFilters>
            }
        }
        resetFilters: () => {
            type: 'reset filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                value: true
            }
        }
        setSelectedRecordingId: (id: SessionRecordingType['id'] | null) => {
            type: 'set selected recording id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                id: string | null
            }
        }
        loadAllRecordings: () => {
            type: 'load all recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                value: true
            }
        }
        loadPinnedRecordings: () => {
            type: 'load pinned recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                value: true
            }
        }
        loadSessionRecordings: (direction?: 'newer' | 'older') => {
            type: 'load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                direction: 'newer' | 'older' | undefined
            }
        }
        maybeLoadSessionRecordings: (direction?: 'newer' | 'older') => {
            type: 'maybe load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                direction: 'newer' | 'older' | undefined
            }
        }
        loadNext: () => {
            type: 'load next (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                value: true
            }
        }
        loadPrev: () => {
            type: 'load prev (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                value: true
            }
        }
        loadEventsHaveSessionId: () => {
            type: 'load events have session id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: any
        }
        loadEventsHaveSessionIdSuccess: (
            eventsHaveSessionId: Record<string, boolean>,
            payload?: any
        ) => {
            type: 'load events have session id success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                eventsHaveSessionId: Record<string, boolean>
                payload?: any
            }
        }
        loadEventsHaveSessionIdFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load events have session id failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadSessionRecordingsSuccess: (
            sessionRecordingsResponse: { has_next: boolean; results: SessionRecordingType[] },
            payload?: {
                direction: 'newer' | 'older' | undefined
            }
        ) => {
            type: 'load session recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                sessionRecordingsResponse: { has_next: boolean; results: SessionRecordingType[] }
                payload?: {
                    direction: 'newer' | 'older' | undefined
                }
            }
        }
        loadSessionRecordingsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load session recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        loadPinnedRecordingsSuccess: (
            pinnedRecordingsResponse: SessionRecordingsResponse | null,
            payload?: {
                value: true
            }
        ) => {
            type: 'load pinned recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                pinnedRecordingsResponse: SessionRecordingsResponse | null
                payload?: {
                    value: true
                }
            }
        }
        loadPinnedRecordingsFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load pinned recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'report recordings list fetched (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'reportRecordingsListFetched'
        'report recordings list filter added (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'reportRecordingsListFilterAdded'
        'maybe load properties for sessions (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'maybeLoadPropertiesForSessions'
        'set filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'setFilters'
        'reset filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'resetFilters'
        'set selected recording id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'setSelectedRecordingId'
        'load all recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadAllRecordings'
        'load pinned recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadPinnedRecordings'
        'load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadSessionRecordings'
        'maybe load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'maybeLoadSessionRecordings'
        'load next (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadNext'
        'load prev (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadPrev'
        'load events have session id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadEventsHaveSessionId'
        'load events have session id success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadEventsHaveSessionIdSuccess'
        'load events have session id failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadEventsHaveSessionIdFailure'
        'load session recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadSessionRecordingsSuccess'
        'load session recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadSessionRecordingsFailure'
        'load pinned recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadPinnedRecordingsSuccess'
        'load pinned recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)': 'loadPinnedRecordingsFailure'
    }
    actionTypes: {
        reportRecordingsListFetched: 'report recordings list fetched (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        reportRecordingsListFilterAdded: 'report recordings list filter added (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        maybeLoadPropertiesForSessions: 'maybe load properties for sessions (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        setFilters: 'set filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        resetFilters: 'reset filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        setSelectedRecordingId: 'set selected recording id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadAllRecordings: 'load all recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadPinnedRecordings: 'load pinned recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadSessionRecordings: 'load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        maybeLoadSessionRecordings: 'maybe load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadNext: 'load next (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadPrev: 'load prev (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadEventsHaveSessionId: 'load events have session id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadEventsHaveSessionIdSuccess: 'load events have session id success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadEventsHaveSessionIdFailure: 'load events have session id failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadSessionRecordingsSuccess: 'load session recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadSessionRecordingsFailure: 'load session recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadPinnedRecordingsSuccess: 'load pinned recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
        loadPinnedRecordingsFailure: 'load pinned recordings failure (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
    }
    actions: {
        reportRecordingsListFetched: (loadTime: number, listingVersion: '1' | '3') => void
        reportRecordingsListFilterAdded: (filterType: SessionRecordingFilterType) => void
        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => void
        setFilters: (filters: Partial<RecordingFilters>) => void
        resetFilters: () => void
        setSelectedRecordingId: (id: SessionRecordingType['id'] | null) => void
        loadAllRecordings: () => void
        loadPinnedRecordings: () => void
        loadSessionRecordings: (direction?: 'newer' | 'older') => void
        maybeLoadSessionRecordings: (direction?: 'newer' | 'older') => void
        loadNext: () => void
        loadPrev: () => void
        loadEventsHaveSessionId: () => void
        loadEventsHaveSessionIdSuccess: (eventsHaveSessionId: Record<string, boolean>, payload?: any) => void
        loadEventsHaveSessionIdFailure: (error: string, errorObject?: any) => void
        loadSessionRecordingsSuccess: (
            sessionRecordingsResponse: { has_next: boolean; results: SessionRecordingType[] },
            payload?: {
                direction: 'newer' | 'older' | undefined
            }
        ) => void
        loadSessionRecordingsFailure: (error: string, errorObject?: any) => void
        loadPinnedRecordingsSuccess: (
            pinnedRecordingsResponse: SessionRecordingsResponse | null,
            payload?: {
                value: true
            }
        ) => void
        loadPinnedRecordingsFailure: (error: string, errorObject?: any) => void
    }
    asyncActions: {
        reportRecordingsListFetched: (loadTime: number, listingVersion: '1' | '3') => Promise<any>
        reportRecordingsListFilterAdded: (filterType: SessionRecordingFilterType) => Promise<any>
        maybeLoadPropertiesForSessions: (sessions: SessionRecordingType[]) => Promise<any>
        setFilters: (filters: Partial<RecordingFilters>) => Promise<any>
        resetFilters: () => Promise<any>
        setSelectedRecordingId: (id: SessionRecordingType['id'] | null) => Promise<any>
        loadAllRecordings: () => Promise<any>
        loadPinnedRecordings: () => Promise<any>
        loadSessionRecordings: (direction?: 'newer' | 'older') => Promise<any>
        maybeLoadSessionRecordings: (direction?: 'newer' | 'older') => Promise<any>
        loadNext: () => Promise<any>
        loadPrev: () => Promise<any>
        loadEventsHaveSessionId: () => Promise<any>
        loadEventsHaveSessionIdSuccess: (eventsHaveSessionId: Record<string, boolean>, payload?: any) => Promise<any>
        loadEventsHaveSessionIdFailure: (error: string, errorObject?: any) => Promise<any>
        loadSessionRecordingsSuccess: (
            sessionRecordingsResponse: { has_next: boolean; results: SessionRecordingType[] },
            payload?: {
                direction: 'newer' | 'older' | undefined
            }
        ) => Promise<any>
        loadSessionRecordingsFailure: (error: string, errorObject?: any) => Promise<any>
        loadPinnedRecordingsSuccess: (
            pinnedRecordingsResponse: SessionRecordingsResponse | null,
            payload?: {
                value: true
            }
        ) => Promise<any>
        loadPinnedRecordingsFailure: (error: string, errorObject?: any) => Promise<any>
    }
    defaults: {
        eventsHaveSessionId: Record<string, boolean>
        eventsHaveSessionIdLoading: boolean
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        pinnedRecordingsResponse: SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: boolean
        unusableEventsInFilter: string[]
        customFilters: RecordingFilters | null
        sessionRecordings: SessionRecordingType[]
        selectedRecordingId: SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: boolean
        pinnedRecordingsAPIErrored: boolean
    }
    events: {}
    key: string
    listeners: {
        loadAllRecordings: ((
            action: {
                type: 'load all recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setFilters: ((
            action: {
                type: 'set filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    filters: Partial<RecordingFilters>
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        resetFilters: ((
            action: {
                type: 'reset filters (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        maybeLoadSessionRecordings: ((
            action: {
                type: 'maybe load session recordings (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    direction: 'newer' | 'older' | undefined
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadSessionRecordingsSuccess: ((
            action: {
                type: 'load session recordings success (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    sessionRecordingsResponse: { has_next: boolean; results: SessionRecordingType[] }
                    payload?: {
                        direction: 'newer' | 'older' | undefined
                    }
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        setSelectedRecordingId: ((
            action: {
                type: 'set selected recording id (scenes.session-recordings.playlist.sessionRecordingsListLogic.*)'
                payload: {
                    id: string | null
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsListLogic', '*']
    pathString: 'scenes.session-recordings.playlist.sessionRecordingsListLogic.*'
    props: SessionRecordingListLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        eventsHaveSessionId: Record<string, boolean>
        eventsHaveSessionIdLoading: boolean
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        pinnedRecordingsResponse: SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: boolean
        unusableEventsInFilter: string[]
        customFilters: RecordingFilters | null
        sessionRecordings: SessionRecordingType[]
        selectedRecordingId: SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: boolean
        pinnedRecordingsAPIErrored: boolean
    }
    reducers: {
        eventsHaveSessionId: (state: Record<string, boolean>, action: any, fullState: any) => Record<string, boolean>
        eventsHaveSessionIdLoading: (state: boolean, action: any, fullState: any) => boolean
        sessionRecordingsResponse: (
            state: SessionRecordingsResponse,
            action: any,
            fullState: any
        ) => SessionRecordingsResponse
        sessionRecordingsResponseLoading: (state: boolean, action: any, fullState: any) => boolean
        pinnedRecordingsResponse: (
            state: SessionRecordingsResponse | null,
            action: any,
            fullState: any
        ) => SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: (state: boolean, action: any, fullState: any) => boolean
        unusableEventsInFilter: (state: string[], action: any, fullState: any) => string[]
        customFilters: (state: RecordingFilters | null, action: any, fullState: any) => RecordingFilters | null
        sessionRecordings: (state: SessionRecordingType[], action: any, fullState: any) => SessionRecordingType[]
        selectedRecordingId: (
            state: SessionRecordingType['id'] | null,
            action: any,
            fullState: any
        ) => SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: (state: boolean, action: any, fullState: any) => boolean
        pinnedRecordingsAPIErrored: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        eventsHaveSessionId: Record<string, boolean>
        eventsHaveSessionIdLoading: boolean
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        pinnedRecordingsResponse: SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: boolean
        unusableEventsInFilter: string[]
        customFilters: RecordingFilters | null
        sessionRecordings: SessionRecordingType[]
        selectedRecordingId: SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: boolean
        pinnedRecordingsAPIErrored: boolean
    }
    selectors: {
        eventsHaveSessionId: (state: any, props?: any) => Record<string, boolean>
        eventsHaveSessionIdLoading: (state: any, props?: any) => boolean
        sessionRecordingsResponse: (state: any, props?: any) => SessionRecordingsResponse
        sessionRecordingsResponseLoading: (state: any, props?: any) => boolean
        pinnedRecordingsResponse: (state: any, props?: any) => SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: (state: any, props?: any) => boolean
        unusableEventsInFilter: (state: any, props?: any) => string[]
        customFilters: (state: any, props?: any) => RecordingFilters | null
        sessionRecordings: (state: any, props?: any) => SessionRecordingType[]
        selectedRecordingId: (state: any, props?: any) => SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: (state: any, props?: any) => boolean
        pinnedRecordingsAPIErrored: (state: any, props?: any) => boolean
        featureFlags: (state: any, props?: any) => FeatureFlagsSet
        autoplayDirection: (state: any, props?: any) => AutoplayDirection
        shouldShowEmptyState: (state: any, props?: any) => boolean
        filters: (state: any, props?: any) => RecordingFilters
        listingVersion: (state: any, props?: any) => '1' | '3'
        activeSessionRecording: (state: any, props?: any) => Partial<SessionRecordingType> | undefined
        nextSessionRecording: (state: any, props?: any) => Partial<SessionRecordingType> | undefined
        hasNext: (state: any, props?: any) => boolean
        totalFiltersCount: (state: any, props?: any) => number
    }
    sharedListeners: {}
    values: {
        eventsHaveSessionId: Record<string, boolean>
        eventsHaveSessionIdLoading: boolean
        sessionRecordingsResponse: SessionRecordingsResponse
        sessionRecordingsResponseLoading: boolean
        pinnedRecordingsResponse: SessionRecordingsResponse | null
        pinnedRecordingsResponseLoading: boolean
        unusableEventsInFilter: string[]
        customFilters: RecordingFilters | null
        sessionRecordings: SessionRecordingType[]
        selectedRecordingId: SessionRecordingType['id'] | null
        sessionRecordingsAPIErrored: boolean
        pinnedRecordingsAPIErrored: boolean
        featureFlags: FeatureFlagsSet
        autoplayDirection: AutoplayDirection
        shouldShowEmptyState: boolean
        filters: RecordingFilters
        listingVersion: '1' | '3'
        activeSessionRecording: Partial<SessionRecordingType> | undefined
        nextSessionRecording: Partial<SessionRecordingType> | undefined
        hasNext: boolean
        totalFiltersCount: number
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        shouldShowEmptyState: (
            sessionRecordings: SessionRecordingType[],
            customFilters: RecordingFilters | null,
            sessionRecordingsResponseLoading: boolean,
            sessionRecordingsAPIErrored: boolean,
            pinnedRecordingsAPIErrored: boolean,
            arg: any
        ) => boolean
        filters: (customFilters: RecordingFilters | null, arg: any) => RecordingFilters
        listingVersion: (
            featureFlags: import('/Users/arunchaitanya/Desktop/open-source/posthog-forked/posthog/frontend/src/lib/logic/featureFlagLogic').FeatureFlagsSet
        ) => '1' | '3'
        activeSessionRecording: (
            selectedRecordingId: string | null,
            sessionRecordings: SessionRecordingType[],
            arg: any
        ) => Partial<SessionRecordingType> | undefined
        nextSessionRecording: (
            activeSessionRecording: Partial<SessionRecordingType> | undefined,
            sessionRecordings: SessionRecordingType[],
            autoplayDirection: import('/Users/arunchaitanya/Desktop/open-source/posthog-forked/posthog/frontend/src/types').AutoplayDirection
        ) => Partial<SessionRecordingType> | undefined
        hasNext: (sessionRecordingsResponse: SessionRecordingsResponse) => boolean
        totalFiltersCount: (filters: RecordingFilters, arg: any) => number
    }
}
