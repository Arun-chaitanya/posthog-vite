// Generated by kea-typegen on Sun, 06 Aug 2023 18:18:14 GMT. DO NOT EDIT THIS FILE MANUALLY.

import type { Logic, BreakPointFunction } from 'kea'

import type { NotebookLogicProps } from './notebookLogic'
import type { NotebookListItemType, NotebookSyncStatus, NotebookType } from '../../../types'
import type { JSONContent, NotebookEditor } from './utils'

export interface notebookLogicType extends Logic {
    actionCreators: {
        receiveNotebookUpdate: (notebook: NotebookListItemType) => {
            type: 'receive notebook update (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                notebook: NotebookListItemType
            }
        }
        setEditor: (editor: NotebookEditor) => {
            type: 'set editor (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                editor: NotebookEditor
            }
        }
        onEditorUpdate: () => {
            type: 'on editor update (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        setLocalContent: (jsonContent: JSONContent) => {
            type: 'set local content (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                jsonContent: JSONContent
            }
        }
        clearLocalContent: () => {
            type: 'clear local content (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        setReady: () => {
            type: 'set ready (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        loadNotebook: () => {
            type: 'load notebook (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        saveNotebook: (notebook: Pick<NotebookType, 'content' | 'title'>) => {
            type: 'save notebook (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                notebook: Pick<NotebookType, 'content' | 'title'>
            }
        }
        exportJSON: () => {
            type: 'export j s o n (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        showConflictWarning: () => {
            type: 'show conflict warning (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                value: true
            }
        }
        loadNotebookSuccess: (
            notebook: NotebookType,
            payload?: {
                value: true
            }
        ) => {
            type: 'load notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                notebook: NotebookType
                payload?: {
                    value: true
                }
            }
        }
        loadNotebookFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'load notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        saveNotebookSuccess: (
            notebook: NotebookType | null,
            payload?: {
                notebook: Pick<NotebookType, 'content' | 'title'>
            }
        ) => {
            type: 'save notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                notebook: NotebookType | null
                payload?: {
                    notebook: Pick<NotebookType, 'content' | 'title'>
                }
            }
        }
        saveNotebookFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'save notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
        duplicateNotebook: () => {
            type: 'duplicate notebook (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: any
        }
        duplicateNotebookSuccess: (
            newNotebook: NotebookType | null,
            payload?: any
        ) => {
            type: 'duplicate notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                newNotebook: NotebookType | null
                payload?: any
            }
        }
        duplicateNotebookFailure: (
            error: string,
            errorObject?: any
        ) => {
            type: 'duplicate notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
            payload: {
                error: string
                errorObject?: any
            }
        }
    }
    actionKeys: {
        'receive notebook update (scenes.notebooks.Notebook.notebookLogic.*)': 'receiveNotebookUpdate'
        'set editor (scenes.notebooks.Notebook.notebookLogic.*)': 'setEditor'
        'on editor update (scenes.notebooks.Notebook.notebookLogic.*)': 'onEditorUpdate'
        'set local content (scenes.notebooks.Notebook.notebookLogic.*)': 'setLocalContent'
        'clear local content (scenes.notebooks.Notebook.notebookLogic.*)': 'clearLocalContent'
        'set ready (scenes.notebooks.Notebook.notebookLogic.*)': 'setReady'
        'load notebook (scenes.notebooks.Notebook.notebookLogic.*)': 'loadNotebook'
        'save notebook (scenes.notebooks.Notebook.notebookLogic.*)': 'saveNotebook'
        'export j s o n (scenes.notebooks.Notebook.notebookLogic.*)': 'exportJSON'
        'show conflict warning (scenes.notebooks.Notebook.notebookLogic.*)': 'showConflictWarning'
        'load notebook success (scenes.notebooks.Notebook.notebookLogic.*)': 'loadNotebookSuccess'
        'load notebook failure (scenes.notebooks.Notebook.notebookLogic.*)': 'loadNotebookFailure'
        'save notebook success (scenes.notebooks.Notebook.notebookLogic.*)': 'saveNotebookSuccess'
        'save notebook failure (scenes.notebooks.Notebook.notebookLogic.*)': 'saveNotebookFailure'
        'duplicate notebook (scenes.notebooks.Notebook.notebookLogic.*)': 'duplicateNotebook'
        'duplicate notebook success (scenes.notebooks.Notebook.notebookLogic.*)': 'duplicateNotebookSuccess'
        'duplicate notebook failure (scenes.notebooks.Notebook.notebookLogic.*)': 'duplicateNotebookFailure'
    }
    actionTypes: {
        receiveNotebookUpdate: 'receive notebook update (scenes.notebooks.Notebook.notebookLogic.*)'
        setEditor: 'set editor (scenes.notebooks.Notebook.notebookLogic.*)'
        onEditorUpdate: 'on editor update (scenes.notebooks.Notebook.notebookLogic.*)'
        setLocalContent: 'set local content (scenes.notebooks.Notebook.notebookLogic.*)'
        clearLocalContent: 'clear local content (scenes.notebooks.Notebook.notebookLogic.*)'
        setReady: 'set ready (scenes.notebooks.Notebook.notebookLogic.*)'
        loadNotebook: 'load notebook (scenes.notebooks.Notebook.notebookLogic.*)'
        saveNotebook: 'save notebook (scenes.notebooks.Notebook.notebookLogic.*)'
        exportJSON: 'export j s o n (scenes.notebooks.Notebook.notebookLogic.*)'
        showConflictWarning: 'show conflict warning (scenes.notebooks.Notebook.notebookLogic.*)'
        loadNotebookSuccess: 'load notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
        loadNotebookFailure: 'load notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
        saveNotebookSuccess: 'save notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
        saveNotebookFailure: 'save notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
        duplicateNotebook: 'duplicate notebook (scenes.notebooks.Notebook.notebookLogic.*)'
        duplicateNotebookSuccess: 'duplicate notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
        duplicateNotebookFailure: 'duplicate notebook failure (scenes.notebooks.Notebook.notebookLogic.*)'
    }
    actions: {
        receiveNotebookUpdate: (notebook: NotebookListItemType) => void
        setEditor: (editor: NotebookEditor) => void
        onEditorUpdate: () => void
        setLocalContent: (jsonContent: JSONContent) => void
        clearLocalContent: () => void
        setReady: () => void
        loadNotebook: () => void
        saveNotebook: (notebook: Pick<NotebookType, 'content' | 'title'>) => void
        exportJSON: () => void
        showConflictWarning: () => void
        loadNotebookSuccess: (
            notebook: NotebookType,
            payload?: {
                value: true
            }
        ) => void
        loadNotebookFailure: (error: string, errorObject?: any) => void
        saveNotebookSuccess: (
            notebook: NotebookType | null,
            payload?: {
                notebook: Pick<NotebookType, 'content' | 'title'>
            }
        ) => void
        saveNotebookFailure: (error: string, errorObject?: any) => void
        duplicateNotebook: () => void
        duplicateNotebookSuccess: (newNotebook: NotebookType | null, payload?: any) => void
        duplicateNotebookFailure: (error: string, errorObject?: any) => void
    }
    asyncActions: {
        receiveNotebookUpdate: (notebook: NotebookListItemType) => Promise<any>
        setEditor: (editor: NotebookEditor) => Promise<any>
        onEditorUpdate: () => Promise<any>
        setLocalContent: (jsonContent: JSONContent) => Promise<any>
        clearLocalContent: () => Promise<any>
        setReady: () => Promise<any>
        loadNotebook: () => Promise<any>
        saveNotebook: (notebook: Pick<NotebookType, 'content' | 'title'>) => Promise<any>
        exportJSON: () => Promise<any>
        showConflictWarning: () => Promise<any>
        loadNotebookSuccess: (
            notebook: NotebookType,
            payload?: {
                value: true
            }
        ) => Promise<any>
        loadNotebookFailure: (error: string, errorObject?: any) => Promise<any>
        saveNotebookSuccess: (
            notebook: NotebookType | null,
            payload?: {
                notebook: Pick<NotebookType, 'content' | 'title'>
            }
        ) => Promise<any>
        saveNotebookFailure: (error: string, errorObject?: any) => Promise<any>
        duplicateNotebook: () => Promise<any>
        duplicateNotebookSuccess: (newNotebook: NotebookType | null, payload?: any) => Promise<any>
        duplicateNotebookFailure: (error: string, errorObject?: any) => Promise<any>
    }
    defaults: {
        localContent: JSONContent | null
        editor: NotebookEditor | null
        ready: boolean
        conflictWarningVisible: boolean
        notebook: NotebookType | null
        notebookLoading: boolean
        newNotebook: NotebookType | null
        newNotebookLoading: boolean
    }
    events: {}
    key: string
    listeners: {
        setLocalContent: ((
            action: {
                type: 'set local content (scenes.notebooks.Notebook.notebookLogic.*)'
                payload: {
                    jsonContent: JSONContent
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        onEditorUpdate: ((
            action: {
                type: 'on editor update (scenes.notebooks.Notebook.notebookLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        saveNotebookSuccess: ((
            action: {
                type: 'save notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
                payload: {
                    notebook: NotebookType | null
                    payload?: {
                        notebook: Pick<NotebookType, 'content' | 'title'>
                    }
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        loadNotebookSuccess: ((
            action: {
                type: 'load notebook success (scenes.notebooks.Notebook.notebookLogic.*)'
                payload: {
                    notebook: NotebookType
                    payload?: {
                        value: true
                    }
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
        exportJSON: ((
            action: {
                type: 'export j s o n (scenes.notebooks.Notebook.notebookLogic.*)'
                payload: {
                    value: true
                }
            },
            previousState: any
        ) => void | Promise<void>)[]
    }
    path: ['scenes', 'notebooks', 'Notebook', 'notebookLogic', '*']
    pathString: 'scenes.notebooks.Notebook.notebookLogic.*'
    props: NotebookLogicProps
    reducer: (
        state: any,
        action: any,
        fullState: any
    ) => {
        localContent: JSONContent | null
        editor: NotebookEditor | null
        ready: boolean
        conflictWarningVisible: boolean
        notebook: NotebookType | null
        notebookLoading: boolean
        newNotebook: NotebookType | null
        newNotebookLoading: boolean
    }
    reducers: {
        localContent: (state: JSONContent | null, action: any, fullState: any) => JSONContent | null
        editor: (state: NotebookEditor | null, action: any, fullState: any) => NotebookEditor | null
        ready: (state: boolean, action: any, fullState: any) => boolean
        conflictWarningVisible: (state: boolean, action: any, fullState: any) => boolean
        notebook: (state: NotebookType | null, action: any, fullState: any) => NotebookType | null
        notebookLoading: (state: boolean, action: any, fullState: any) => boolean
        newNotebook: (state: NotebookType | null, action: any, fullState: any) => NotebookType | null
        newNotebookLoading: (state: boolean, action: any, fullState: any) => boolean
    }
    selector: (state: any) => {
        localContent: JSONContent | null
        editor: NotebookEditor | null
        ready: boolean
        conflictWarningVisible: boolean
        notebook: NotebookType | null
        notebookLoading: boolean
        newNotebook: NotebookType | null
        newNotebookLoading: boolean
    }
    selectors: {
        localContent: (state: any, props?: any) => JSONContent | null
        editor: (state: any, props?: any) => NotebookEditor | null
        ready: (state: any, props?: any) => boolean
        conflictWarningVisible: (state: any, props?: any) => boolean
        notebook: (state: any, props?: any) => NotebookType | null
        notebookLoading: (state: any, props?: any) => boolean
        newNotebook: (state: any, props?: any) => NotebookType | null
        newNotebookLoading: (state: any, props?: any) => boolean
        scratchpadNotebook: (state: any, props?: any) => NotebookListItemType
        notebookTemplates: (state: any, props?: any) => NotebookType[]
        shortId: (state: any, props?: any) => string
        isLocalOnly: (state: any, props?: any) => boolean
        content: (state: any, props?: any) => JSONContent
        title: (state: any, props?: any) => string
        isEmpty: (state: any, props?: any) => boolean
        syncStatus: (state: any, props?: any) => NotebookSyncStatus
    }
    sharedListeners: {
        onNotebookChange: (
            payload: any,
            breakpoint: BreakPointFunction,
            action: {
                type: string
                payload: any
            },
            previousState: any
        ) => void | Promise<void>
    }
    values: {
        localContent: JSONContent | null
        editor: NotebookEditor | null
        ready: boolean
        conflictWarningVisible: boolean
        notebook: NotebookType | null
        notebookLoading: boolean
        newNotebook: NotebookType | null
        newNotebookLoading: boolean
        scratchpadNotebook: NotebookListItemType
        notebookTemplates: NotebookType[]
        shortId: string
        isLocalOnly: boolean
        content: JSONContent
        title: string
        isEmpty: boolean
        syncStatus: NotebookSyncStatus
    }
    _isKea: true
    _isKeaWithKey: true
    __keaTypeGenInternalSelectorTypes: {
        shortId: (arg: any) => string
        isLocalOnly: (arg: any) => boolean
        content: (notebook: NotebookType | null, localContent: JSONContent | null) => JSONContent
        title: (notebook: NotebookType | null, content: JSONContent) => string
        isEmpty: (editor: NotebookEditor | null, content: JSONContent) => boolean
        syncStatus: (
            notebook: NotebookType | null,
            notebookLoading: boolean,
            localContent: JSONContent | null,
            isLocalOnly: boolean
        ) => NotebookSyncStatus
    }
}
